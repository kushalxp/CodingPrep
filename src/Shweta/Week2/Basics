1. How do we declare an array?
    int a[]; or int[] a;
    Here we just declared an array variable and did not assign any memory
    So only reference is created, memory is not allocated
2. How do we declare array of 5 elements size
    int a[] = new a[5];
    We use new keyword to allocate memory.
3. What is the default value of above array?
    [0, 0, 0, 0, 0]
4. How does JVM allocate memory?
    JVM allocates the array memory on the heap.
5. How is float declared?
    we should append the letter f to the end of the data type; otherwise it will save as double.
    float a = 2.356f; float x = -125.563f; float q = 506.12789f;
    float r = -101.23; saved as double because value is not appended with the letter f.
    float c = 101.123456789123; error!! a float in Java can only store a maximum of 7 digits after decimal.
6. How is double declared?
    double data type stores decimal values with 15-16 digits of precision. Remember that the default value is 0.0d
    double a = 2.356; double x = -125.563; double q = 506.124789; double r = -101.1234567891234567;
    double c = 101.123456789123456789; error!! a double in Java can only store a maximum of 16 digits
7. Which datatype used to store currency values?
    Neither float/double because it cannot store data with very high precision.
    Java has a class called BigDecimal that specifies the exact number of digits following the decimal,
    including rounding up or down.
8. What is datatype?
    Every variable has datatype. It specifies size and type of value that can be stored in identifier
    Types: Primitive(Intrinsic or built-in data type), Non-Primitive(derived or reference data type)
9. Primitive DataType
    8 primitive datatype: byte, short, int, float, double, char, boolean
    +-----------+---------------+
    | Data Type | Default Value |
    +-----------+---------------+
    | byte      | 0             |
    | short     | 0             |
    | int       | 0             |
    | long      | 0L            |
    | float     | 0.0f          |
    | double    | 0.0d          |
    | boolean   | false         |
    | char      | '\u0000'      |
    +-----------+---------------+
    Variables with the local scope are always primitive type
    Unexpected defaults while incorrectly using primitive types
    primitive data cannot be stored in Collection as it is not an Object!
    Java collection framework works with objects only.
    Stored in a stack.
    Primitive data types do not have null as default value
    All classes of the collection framework (ArrayList, LinkedList, Vector, HashSet, LinkedHashSet, TreeSet, PriorityQueue, ArrayDeque, etc.) deal with objects only.
10. Wrapper Class
    Wrapper classes is a way to wrap or represent the value of primitive data types as an object.
    +-----------+---------------+
    | Data Type | Wrapper Type  |
    +-----------+---------------+
    | byte      | Byte          |
    | short     | Short         |
    | int       | Integer       |
    | long      | Long          |
    | float     | Float         |
    | double    | Double        |
    | boolean   | Boolean       |
    | char      | Character     |
    +-----------+---------------+
    Database Models should use wrapper class
    Databases can have all kinds of values including null, so Model Objects or Entities must always have Wrapper Classes
    DTOs (Request and Response)
    DTOs used for Request and Response may have Wrapper Classes if your API design includes nullable values
    NullPointerException while incorrectly using Wrapper Classes
    Additional memory usage while incorrectly using Wrapper Classes
    The classes in java.util package handles only objects and hence wrapper classes help in this case also.
    All of the numeric wrapper classes are subclasses of the abstract class Number such as Byte, Integer, Double, Short, Float, Long.
    Reference variable is stored in stack and the original object is stored in heap
    The default value for the reference variable is null
11. Autoboxing: Automatic conversion of primitive types to the object of their corresponding wrapper classes is known as autoboxing.
    For example – conversion of int to Integer, long to Long, double to Double etc.
        int a=20;
        Integer i=Integer.valueOf(a);//converting int into Integer explicitly
        Integer j=a;//autoboxing, now compiler will write Integer.valueOf(a) internally
12. Unboxing: It is just the reverse process of autoboxing.
    Automatically converting an object of a wrapper class to its corresponding primitive type is known as unboxing.
    For example – conversion of Integer to int, Long to long, Double to double, etc.
        //Converting Integer to int
        Integer a=new Integer(3);
        int i=a.intValue();//converting Integer to int explicitly
        int j=a;//unboxing, now compiler will write a.intValue() internally
13. What are Arrays?
    Collection of Homogeneous data. It needs same DataType.
    Default is [0, 0, 0, 0, 0, ... ] if nothing is added in an array
    eg: [1,2,3,4..] Valid
    eg: [1, "abc", 2.8, 'a', .. ] InValid
    // declares an array of integers
    int[] anArray;
    // allocates memory for 10 integers
    anArray = new int[10];
    // initialize first element
    anArray[0] = 100;
    // initialize second element
    anArray[1] = 200;
    // and so forth
    anArray[2] = 300;
    ** declare arrays of other types:
    byte[] anArrayOfBytes;
    short[] anArrayOfShorts;
    long[] anArrayOfLongs;
    float[] anArrayOfFloats;
    double[] anArrayOfDoubles;
    boolean[] anArrayOfBooleans;
    char[] anArrayOfChars;
    String[] anArrayOfStrings;
14. Merits of Array
    >
15. Demerits of Array

5. What is JVM?
    JVM:: runtime engine
    When we compile a .java file, compiler creates .class files with same name as .java file
    Class Loader:: reads the .class file, generates binary data save in method area.
    After Loading:: object of type Class(java.lang pkg) to represent the .class file is created in Heap memory.
    Class Object:: used to get class level info eg:name of class, parent name, methods, variable info etc
    Object Reference:: we use getClass() method of Object Class.
    Linking:: Verification -> Preparation -> Resolution
    Verification:: checks file is correctly formatted and generated by valid compiler or not.
    If verification fails we get run-time exception java.lang.VerifyError.
    Preparation:: JVM allocates memory for class static variables and initializing the memory to default values.
    Resolution:: Replaces symbolic references with direct references. Done by searching in method area.
    Initialization:: All static variables are assigned values defined in code
    Class Loader:: Bootstrap, Extension, System/Application Class Loader
    Bootstrap:: must for every JVM. Loads core java API trusted classes “JAVA_HOME/jre/lib” directory.
    Extension:: child of bootstrap. Loads classes in “JAVA_HOME/jre/lib/ext”(Extension path) or
    any other directory specified by the java.ext.dirs system property.
    System/Application:: child of the extension class loader. Load classes from the application classpath.
    It internally uses Environment Variable which mapped to java.class.path.
    Why do we get java.lang.ClassNotFoundException?
    >> JVM follows Delegation-Hierarchy principle to load classes.
    System class loader -> delegates loads to -> extension class loader -> delegates loads to -> bootstrap class loader
    Class Found in bootstrap path :: No Exception and Class gets loaded
    Class Not Found in bootstrap path :: request again transfers -> extension class loader -> System class loader
    Class Not Found in System class path :: Run-time Exception ClassNotFoundException
    Method Area:: Class level info(class name, method name, parent class, var info, etc)
    Heap Area:: Info about objects(instance var)
    Stack Area:: 1 thread = 1 runtime stack
    PC Register:: Store address of current execution instruction of a thread. 1thread = 1PC register
    Native method stacks:: For every thread, a separate native stack is created. It stores native method information.
    Execution Engine:: Executes .class bytecode line by line, uses data and information present in various memory area and executes instructions.
    Interpreter::  It interprets the bytecode line by line and then executes.
    The disadvantage here is that when one method is called multiple times, every time interpretation is required.
    Just-In-Time Compiler(JIT) : It is used to increase the efficiency of an interpreter.
    It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls,
    JIT provides direct native code for that part so re-interpretation is not required, thus efficiency is improved.
    Garbage Collector: It destroys un-referenced objects.
    Java Native Interface (JNI) :
    It is an interface that interacts with the Native Method Libraries and provides the native libraries(C, C++) required for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

